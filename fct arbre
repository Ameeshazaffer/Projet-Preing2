                                                                      // toutes les fonctions pour afficher la perte d'eau d'une usine //


                                                                                           // structures //

typedef struct{
	char* id; // identifiants du distributeurs d'eau
	int volume_initial;
	Liste* enfants;
}Noeud;

typedef struct Noeud* pNoeud; 

typedef struct {
	Noeud* enfant; // en aval
	float fuites_pourcentage; // pourcentage de fuites 
	struct Liste* suivant; //
}Liste; 

typedef struct Liste* pListe; 


typedef struct avl{
	char* id;
    pNoeud noeud;
    int eq;                   
    struct avl *fg;
    struct avl *fd;
}AVL_sup;

typedef AVL_sup *pAVL_sup;


typedef struct {
    char usine[50];
    char amont[50];
    char aval[50];
    float volume;
    float coeff;
} LigneCSV;










                                                                                        // partie 1 : fonctions qui crées arbre classique //

pNoeud creerNoeud(const char* identifiant){
	pNoeud noeud=malloc(sizeof(Noeud));
	if(noeud==NULL){
		return NULL;
	}
	noeud->id=malloc(strlen(identifiant)+1); // faire de la mémoire pour la chaîne de carcatère de l'identifiant
	if(noeud->id==NULL){
		free(noeud); // libérer mémoire allouée du noeud 
		return NULL;
	}
	strcpy(noeud->id, identifiant);
	noeud->volume_initial=0;
	noeud->enfants=NULL; (initialiser la liste d'enfant à NULL)
	return noeud;
}


// fonction qui crée un enfant de la liste 

pListe creerenfant(pNoeud aval, float fuite){
	pListe a= malloc(sizeof(Liste));
	if(a==NULL){
		return NULL;
	}
	a->enfant=aval;
	a->fuites_pourcentages=fuite;
	a->suivant=NULL;
	return a;
}



// ajouter l'enfant

void ajouterenfant(pNoeud parent, pNoeud enfant, float fuites){
	pListe a=creerenfant(enfant, fuites);
	if (a == NULL){
		return NULL;
	}
	a->suivant=parent->enfants; 
	parent->enfants=a;
}

// créer un AVL supplémentaire

pAVL_sup creerAVL_sup(const char* id){
    pAVL_sup n = malloc(sizeof(AVL_sup));
    if (n == NULL) {
        return NULL;
    }
    n->id = malloc(strlen(id) + 1);
	if (n->id==NULL){
		free(n);
		return NULL);
	}
    strcpy(n->id, id);
	n->noeud= noeud;
    n->eq = 0;
    n->fg = NULL;
    n->fd = NULL;
    return n;
}


// rechercher noeud avec avl - retourne null ou adresse neoud 
int min(int a, int b){
    if(a < b){
        return a;
    }else{
        return b;
    }    
}

int max(int a, int b){
    if(a > b){
        return a;
    }else{
        return b;
    }    
}

int min3(int a, int b, int c){
  return min(min(a,b),c);
}

int max3(int a, int b, int c){
  return max(max(a,b),c);
}


pAVL rotationDroite(pAVL a){
    pAVL pivot = a->fg;
    int eq_a = a->eq;
    int eq_p = pivot->eq;
    a->fg = pivot->fd;
    pivot->fd = a;
    a->eq = eq_a - min(eq_p, 0) + 1;
    pivot->eq = max3(eq_a + 2, eq_a + eq_p + 2, eq_p + 1);
    return pivot;
}

pAVL rotationGauche(pAVL a){
    pAVL pivot = a->fd;
    int eq_a = a->eq;
    int eq_p = pivot->eq;
    a->fd = pivot->fg;
    pivot->fg = a;
    a->eq = eq_a - max(eq_p, 0) - 1;
    pivot->eq = min3(eq_a - 2, eq_a + eq_p - 2, eq_p - 1);
    return pivot;
}

pAVL doubleRotationGauche(pAVL a){
    a->fd = rotationDroite(a->fd);
    return rotationGauche(a);
}

pAVL doubleRotationDroite(pAVL a){
    a->fg = rotationGauche(a->fg);
    return rotationDroite(a);
}


pAVL equilibrerAVL(pAVL a){
    if (a->eq >= 2){
        if (a->fd->eq >= 0){
            return rotationGauche(a);
        }else{
            return doubleRotationGauche(a);
        }
    }else if (a->eq <= -2){
        if(a->fg->eq <= 0){
            return rotationDroite(a);
        }else{
            return doubleRotationDroite(a);
        }
    }
    return a;
}

pNoeud rechercheAVL(pAVL_sup a, char* id){
    if (a == NULL){
        return NULL;
    }
    if(strcmp(id, a->id) == 0){
        return a->noeud;
    }else if(strcmp(id, a->id) < 0){
        return rechercheAVL(a->fg, id);
    }else{
        return rechercheAVL(a->fd, id);
    }
}

// insérer noeud dans avl 

pAVL_sup insertionAVL(pAVL_sup a, const char* id, pNoeud n, int* h){
    if (a == NULL) {
        *h = 1;
        return creerAVL_sup(id, n);
    }
    
    if (strcmp(id,a->id) < 0){
        a->fg = insertionAVL_sup(a->fg, id, n, h);
        *h = -*h;
    }
	else if(strcmp(u->id, a->usine.id) > 0){
        a->fd = insertionAVL_sup(a->fd, id, n, h);
    }
	else{
        *h = 0;
        return a; 
    }

    if(*h != 0){
        a->eq += *h;
        if(a->eq == 0){
            *h = 0;
        }else{
            *h = 1;
        }
    }

    return equilibrerAVL_sup(a);
}



// regarder si noeud existe sinon créer noeud et inserer dans avl - retourner adresse neoud 

pNoeud obtenirnoeud(pAVL_sup* a, const char* id){
	pAVL_sup a = rechercheAVL(pAVL_sup* a, const char* id)
	if ( a!=NULL ){
		return a->noeud; 
	}
	else{
		pNoeud n=creerNoeud(id);
		if(n=NULL){
			return NULL;
		}
		int h=0; 
		*a=insertionAVL_sup(a, id, n, h) // on met pointeur pour que ça modifie dans tout le programme 
		return n;
	}
}
		

// fonction qui traite une ligne

void traiter_une_ligne(LigneCSV* l, pAVL_sup* a){

// source -> usine 
	
	if(strcmp(l->usine, "-")==0 && strcmp(l->amont,"-")!=0 && strcmp(l->aval, "-")!=0 && ( l->volume>0 )){
		pNoeud usine=obtenirnoeud(a, l->aval);

		float volume_après_fuites = l->volume*(1-(l->coeff/100.0));
		usine->volume_initial += volume_après_fuites; // car plusieurs sources peuvent rentrer dans une usine 


// usine 

	if(strcmp(l->usine, "-")==0 && strcmp(l->amont,"-")!=0 && strcmp(l->aval, "-")==0 && ( l->volume>0 )){
		pNoeud usine=obtenirnoeud(a, l->amont){



// usine->stockage & stockage->jonction & jonction->raccordement & raccordement->usager

	if((strcmp(l->amont, "-")!=0 && ( l->aval!=0 )&& (volume==0){
		pNoeud noeud_amont=obtenirnoeud(a, l->amont)
		pNoeud noeud_aval=obtenirnoeud(a, l->aval)

		ajouterenfant(noeud_amont, noeud_aval, l->coeff)
}


int lireLigne(FILE* f, LigneCSV* l){
	return fscanf(f, "%49[^;];%49[^;];%49[^;];%f;%f\n",l->usine, l->amont, l->aval, &l->volume, &l->coeff)==5; 
}


// construire arbre 
void construire_arbre(FILE* f, pAVL_sup* a){
	LigneCSV l;
	while(lireLigne(f, &l)){
		traiter_une_ligne(&l, a);
	}
}


// les lignes du fichier

présent dans le fichier : 

int typeLigne(const char *usine,const char *amont,const char *aval, const char *volume, const char *fuites){
    if (strcmp(usine, "-") == 0 && strcmp(amont, "-") != 0 && strcmp(aval, "-") == 0 && strcmp(volume, "-") != 0 && strcmp(fuites, "-") == 0) { 
        return 1;
    }
    if(strcmp(usine, "-") == 0 && strcmp(amont, "-") != 0 && strcmp(aval, "-") != 0 && strcmp(volume, "-") != 0 && strcmp(fuites, "-") != 0) {
        return 2;
    }
	if(strcmp(usine, "-") != 0 && strcmp(amont, "-") != 0 && strcmp(aval, "-") != 0 && strcmp(volume, "-") == 0 && strcmp(fuites, "-") != 0) {
        return 3;
    }
    return 0;
}


                            // partie 2 : fonctions qui calculent la perte d'eau d'une seule usine ( compte le nombre d'enfants + répartition volumes + addition pertes + créer le fichier et ajoute ligne dedans ) //


Pnoeud vérification_ identifiant(){
	a = rechercheAVL(pAVL_sup a, char* id); 
	if (a==NULL){
		return NULL;
	}
	if(a->volume_initial<=0){
		return NULL;
	}
	return a; 
}


int compter_enfants(pNoeud noeud){
	int count=0;
	while (noeud->enfants!=NULL){
		count ++;
		noeud->enfants=noeud->enfants->suivant; 
	}
	return count;
}


float calcul_pertes(adresse du noeud, volume){
	float pertes = 0.0;
	float volume_par_enfants, fuites, volumes_après_fuites;
	int nombre_enfants
	if (noeud=estFeuille(noeud)){
		retourn 0.0; 
	}
	nombre_enfants=compter_enfants(noeud);
	volume_par_enfants=volume/nombre_enfants;
	pListe actuel= noeud->enfants; 
	while(actuel!=NULL){
		fuites=actual->fuites_pourcentages/100.0;
		volumes_après_fuites=volume_par_enfant*(1-fuites);
		pertes += volume_enfant - volume_après_fuites;

		pertes += calcul_pertes(actuel->enfants, volume_après_fuites);
		actuel=actuel->suivant; 

	}
	float pertes_totales = pertes/1000.0; 
	return pertes_totales; 
}




void ajout_résulat_fichier(char* identifiant, float volume_pertes){
	FILE* fichier = fopen("leaks.dat", "a");
	if(fichier == NULL){
		exit(1);
	}
	fputs(fichier, "%s;%.3fk.m3\n, identifiant, volume_pertes);
	fclose(fichier);
}

int calcul_final_pertes(avl, identifiant_usine){

	pNoeud usine = vérification_ identifiant(identifiant_usine);
	if(usine==NULL){
		return -1;
	}
	float volume_pertes = calcul_pertes(adresse du noeud);
	ajout_résulat_fichier(identifiant,volume_pertes); 
	return volumes_pertes; 
}


                                                       // ce qu'il faut mettre dans le programme principal //


int main (){
	FILE* fichier = NULL;  // ouverture du fichier c-wildwater_v0.dat en mode lecture et écriture
	fichier = fopen("c-wildwater_v0.dat", "r+");
	if (fichier == NULL){
		printf("Ouverture du fichier impossible");
		exit(1);
	}

	pAVL_sup a= NULL; 
	constuire_arbre(fichier, &a);
	fclose(fichier);
	
	char id_usine[50];
	printf("Entrer l'identifiant de l'usine :");
	scanf("%49s", &id_usines);




	int pertes=calculerPertes(,);
	printf("Le volume d'eau perdue par l'usine, dont l'identifiant est %49s, est %d\n", id_usines, pertes);


	libérer tout;
	return 0; 
}

	
