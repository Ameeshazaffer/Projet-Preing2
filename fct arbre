                              // toutes les fonctions pour afficher la pertes d'eau d'une usine //


// structures 

typedef struct{
	char* id; // identifiants du distributeurs d'eau
	int volume_initial;
	Liste* liste;
}Arbre;

typedef struct Arbre* pArbre; 

typedef struct Liste{
	Arbre* enfant; // en aval
	float fuites_pourcentage; // pourcentage de fuites 
	struct Liste* suivant; //
}Liste; 

typedef struct Liste* pListe; 


// fonction qui crée arbre 

pArbre creerArbre(char e){
	pArbre noeud=malloc(sizeof(Arbre));
	if(noeud==NULL){
		exit(EXIT_FAILURE);
	}
	noeud->id=e;
	noeud->enfant=NULL;
	return noeud;
}

// fonction qui crée une liste d'enfant

pListe creerenfant(pArbre e, float fuite){
	pArbre e= mallocsizeof(Arbre);
	if(e==NULL){
		printf("Erreur allocation mémoire arbre");
		exit(EXIT_FAILURE);
	}
	e->fuite_pourcentage=fuites; 
}



// fonction qui ajoute les enfants ( aide AVL supllémentaire pour retrouver et retourner adresse du noeud )

pArbre ajouterenfants(Parbre, ){	                                                                                                                                                                                                                                                                    
	-  parcourir une ligne du ficheir csv 
	- lire parent, enfant, fuites
	- verifier si noeud parent existe ( si non créer ), ajouter dans avl ( avl pas pour construuire arbre ?
	- verifier si noeud enfant existe ( si non créer ) mais de base y pas encore nan + ajouter dans l'avl
	- ajouter l'enfant dans la liste chainées du parents et mettre % fuites
	- recommencer pour la ligne suivante ... 





}


// fonction qui calcul la perte ( compte le nombre d'enfants + répartition volumes + addition pertes ) 


recherche AVL(avl, id_usines){
	- retourne adresse du neoud où se trouve l'usine 
	- retourne null si pas trouvé
	- si identifiant pas d'une usine ? ( on met retourner 0), ( ou on fait quand même depuis usine donc retourne adresse usine, ou on commence au noeud de l'identifiant donné donc retourne adresse du noeud) ( ou on met que les usines dans l'avl ? donc on retourne -1 vu que pas trouvé ) 
}


int compter_enfants(){


}

float calcul_pertes(adresse du noeud){
	int volume=noeud->volume_initial;
	parcourir le noeud : si enfant, continuer à chaque fois : 
	calculer fuites noeud = volume; 
	repartir volume/nombre_enfants;
	si pas enfant calculer les fuites du noeud ou enfants actuelle
	volume_initial-volume = volume_pertes;
	return volume_pertes;

}







main : 
- ajouter enfant
- recherche avl 
- si null donc pas trouver - retourner -1
- calcul_pertes_eau(adresse du noeud)












// fonctions vu en cours pour arbre //

typedef struct Chainon{
  int valeur; 
  struct Chainon* next;
}Chainon; 

typedef struct{
  int valeur; 
  Arbre* fg, fd;
} Arbre; 

// création de l'arbre
pArbre creerArbre(int e){
	pArbre noeud=malloc(sizeof(Arbre));
	if(noeud==NULL){
		exit(EXIT_FAILURE);
	}
	noeud->valeur=e;
	noeud->fd=NULL;
	noeud->fg=NULL;
	return noeud;
}

// arbre vide ? 
int estVide(pArbre* a){
    return (a==NULL);
  }

// est une feuille ? 
int estFeuille(pArbre* a){
  if(a==NULL){
    exit(EXIT_FAILURE);
  }
  if(a->fd==NULL && a->fg==NULL){
    return 1;
  }
  else{
    return 0; 
  }
}

// vérifie si filsgauche/filsdroit existe 

int existeFilsDroit(pArbre* a){
  if( a==NULL ){
    exit(EXIT_FAILURE);
  }
  else if (a->fd==NULL){
    return 0; 
  }
  else{
  return 1; 
  }
}

int existeFilsGauche(pArbre* a){
  if( a==NULL ){
    exit(EXIT_FAILURE);
  }
  else if (a->fg==NULL){
    return 0; 
  }
  else{
  return 1; 
  }
}

// retourne adresse du filsdroit/fisgauche

int filsDroit( pArbre* a ){
  if( a==NULL ){
    exit(EXIT_FAILURE);
  }
  else if(existeFilsDroit(a)){
    return a->fd; 
  }
  else{
    return NULL;
  }

}
int filsGauche( pArbre* a ){
  if( a==NULL ){
    exit(EXIT_FAILURE);
  }
  else if(existeFilsGauche(a)){
    return a->fg; 
  }
  else{
    return NULL;
  }

}

// modifier élément

void modifier element( Parbre* a, int element){
  if (a == NULL){
    exit(EXIT_FAILURE);
  }
  else{
  a->value=element; 
  }
}


// ajouter fis gauche/fils droit

int ajouterFilsDroit( pArbre* a, int e){
  if(a==NULL){
    return 0; 
  }
  else if(!existeFilsDroit(a)){
    a->fd=creerArbre(e);
    return 1;
  }
  else{
    return 0; 
  }
}

int ajouterFilsGauche( pArbre* a, int e){
  if(a==NULL){
    return 0; 
  }
  else if(!existeFilsGauche(a)){
    a->fg=creerArbre(e);
    return 1;
  }
  else{
    return 0; 
  }
}


// supprimer un noeud 

void supprimerFilsDroit(pArbre* a){
  if(a==NULL){
    exit(EXIT_FAILURE);
  }
  else if(existeFilsDroit(a)){
    if(existeFilsGauche(a->fd)){
      supprimerFilsGauche(a->fd);
    }
    if(existeFilsDroit(a->fd)){
      supprimerFilsDroit(a->fd);
    }
    free(a->fd); 
  }
}

void supprimerFilsGauche(pArbre* a){
  if(a==NULL){
    exit(EXIT_FAILURE);
  }
  else if(existeFilsGauche(a)){
    if(existeFilsGauche(a->fg)){
      supprimerFilsGauche(a->fg);
    }
    if(existeFilsDroit(a->fg)){
      supprimerFilsDroit(a->fg);
    }
    free(a->fg); 
  }
}

// parcours Infixe

void parcoursInfixe(pArbre* a){
  if(a !=NULL){
    parcoursInfixe(a->fg);
    traiter(a->valeur);
    parcoursInfixe(a->fd);
  }
}

// parcours Prefixe

void traiter(pArbre* a){
	if(estVide(a)){	
		printf("vide\n");
	}
	else{
	printf("%d\n", a->valeur);
	}
}

void parcoursPrefixe(pArbre* a){
	if ( a!=NULL){
		traiter (a);
		parcoursPrefixe(a->fg);
		parcoursPrefixe(a->fd);
	}
}

// parcours Largeur 

void parcoursLargeur(pArbre* a){
	pArbre* noeud; 
	File* f; 
	if(!estVide(a)){
		creerFile(f); 
		enfiler(f, a);
		while(fileVide(f)){
			noeud=defiler(f);
			traiter(noeud);
			if(existeFilsGauche(noeud)){
				enfiler(f, noeud->fg);
			}
			if(existeFilsDroit(noeud)){
				enfiler(f, noeud->fd);
			}
		}
	}
}


