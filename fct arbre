                                                                      // toutes les fonctions pour afficher la perte d'eau d'une usine //


                                                                                     // structures //

typedef struct{
	char* id; // identifiants du distributeurs d'eau
	int volume_initial;
	Liste* enfants;
}Noeud;

typedef struct Noeud* pNoeud; 

typedef struct {
	Noeud* enfant; // en aval
	float fuites_pourcentage; // pourcentage de fuites 
	struct Liste* suivant; //
}Liste; 

typedef struct Liste* pListe; 


typedef struct avl{
	char* id;
    pNoeud noeud;
    int eq;                   
    struct avl *fg;
    struct avl *fd;
}AVL_sup;

typedef AVL_sup *pAVL_sup;





                                                   // fonction qui crée arbre classique //

pNoeud creerNoeud(const char* identifiant){
	pNoeud noeud=malloc(sizeof(Noeud));
	if(noeud==NULL){
		return NULL;
	}
	noeud->id=malloc(strlen(identifiant)+1); // faire de la mémoire pour la chaîne de carcatère de l'identifiant
	if(noeud->id==NULL){
		free(noeud); // libérer mémoire allouée du noeud 
		return NULL;
	}
	strcpy(noeud->id, identifiant);
	noeud->volume_initial=0;
	noeud->enfants=NULL; (initialiser la liste d'enfant à NULL)
	return noeud;
}


// fonction qui crée un enfant de la liste 

pListe creerenfant(pNoeud aval, float fuite){
	pListe a= malloc(sizeof(Liste));
	if(a==NULL){
		return NULL;
	}
	a->enfant=aval;
	a->fuites_pourcentages=fuite;
	a->suivant=NULL;
	return a;
}



// ajouter l'enfant

void ajouterenfant(pNoeud parent, pNoeud enfant, float fuites){
	pListe a=creerenfant(enfant, fuites);
	if (a == NULL){
		return NULL;
	}
	a->suivant=parent->enfants; 
	parent->enfants=a;
}

// créer un AVL supplémentaire

pAVL_sup creerAVL_sup(const char* id){
    pAVL_sup n = malloc(sizeof(AVL_sup));
    if (n == NULL) {
        return NULL;
    }
    n->id = malloc(strlen(id) + 1);
	if (n->id==NULL){
		free(n);
		return NULL);
	}
    strcpy(n->id, id);
	n->noeud= noeud;
    n->eq = 0;
    n->fg = NULL;
    n->fd = NULL;
    return n;
}


// rechercher noeud avec avl - retourne null ou adresse neoud 


pNoeud rechercheAVL(pAVL_sup a, char* id){
    if (a == NULL){
        return NULL;
    }
    if(strcmp(id, a->id) == 0){
        return a->noeud;
    }else if(strcmp(id, a->id) < 0){
        return rechercheAVL(a->fg, id);
    }else{
        return rechercheAVL(a->fd, id);
    }
}

// insérer noeud dans avl 

pAVL_sup insertionAVL(pAVL_sup a, const char* id, pNoeud n, int* h){
    if (a == NULL) {
        *h = 1;
        return creerAVL_sup(id, n);
    }
    
    if (strcmp(id,a->id) < 0){
        a->fg = insertionAVL_sup(a->fg, id, n, h);
        *h = -*h;
    }
	else if(strcmp(u->id, a->usine.id) > 0){
        a->fd = insertionAVL(a->fd, id, n, h);
    }
	else{
        *h = 0;
        return a; 
    }

    if(*h != 0){
        a->eq += *h;
        if(a->eq == 0){
            *h = 0;
        }else{
            *h = 1;
        }
    }

    return equilibrerAVL_sup(a);
}



// regarder si noeud existe sinon créer noeud et inserer dans avl - retourner adresse neoud 

pNoeud obtenirnoeud(pAVL_sup* a, const char* id){
	pAVL_sup a = rechercheAVL(pAVL_sup* a, const char* id)
	if ( a!=NULL ){
		return a->noeud; 
	}
	else{
		pNoeud n=creerNoeud(id);
		if(n=NULL){
			return NULL;
		}
		int h=0; 
		*a=insertionAVL_sup(a, id, n, h) // on met pointeur pour que ça modifie dans tout le programme 
		return n;
	}
}
		



// traiter une ligne
void traiter_une_ligne(){
	stocker id amont 
	stocker id aval
	stcoker fuites 
	pNoeud noeud_amont=obtenirnoeud(a, id_amont)
	pNoeud noeud_amont=obtenirnoeud(a, id_aval)
	if (noeud_amont == NULL || noeud_aval == NULL ){
		
	ajouterenfant(neoud_amont, fuites)
	
- prend id amont ( ex : usine ) 
- prend id aval ( ex : espace de stockage )
- on obtient le noeud qui correspond a id amont 
- ajoute enfant a id amont qui est id aval ( mettre fuites aussi ) 
- faire attention lors de lecture car en fonction des distributeurs d'eau, ligne pas même syntaxe



// construire arbre 
lire ligne par ligne 
et donc appeler la fonction traiterligne 








































































présent dans le fichier : 

source/usine : 
- identifiant source 
- identifiant usine
- quantité annuelle capté 
- pourcentage de fuites

usine : 
- identifiant usine 
- capacité maximale de traitement

usine/stockage : 
- identifiant usine 
- identifiant stockage
- pourcentage de fuites 

stockage/jonction : 
- identifiant espace de stockage
- identifiant jonction 
- identifiant usine qui a traité l'eau 
- pourcentage de fuites 

jonction/raccordement :
- identifiant jonction 
- identifiant raccordement 
- identifiant usine qui a traité l'eau 
- pourcentage de fuites 

raccordement/usager : 
- identifiant raccordement
- identifiant usager 
- pourcentage de fuites 
- identifiant de l'usine 



SCHEMA GLOBALE DU CODE : 
lire une ligne du fichier : 
- traiter la ligne 
- retrouver l'adresse du noeud avec l'avl 
- ajouter l'enfant dans l'arbre 
ainsi de suite jusqu'à que fichier est NULL 
































          // fonction qui calcul la perte ( compte le nombre d'enfants + répartition volumes + addition pertes + créer le fichier et ajoute ligne dedans ) //


vérification_ identifiant(){
si identifiant pas trouver - retourner -1
si identifiant pas d'une usine ? ( on met retourner 0), ( ou on fait quand même depuis usine donc retourne adresse usine, ou on commence au noeud de l'identifiant donné donc retourne adresse du noeud) ( ou on met que les usines dans l'avl ? donc on retourne -1 vu que pas trouvé )
}
int compter_enfants(){

count ++
}

float calcul_pertes(adresse du noeud){
	int volume = noeud->volume_initial;
	parcourir le noeud : si enfant, continuer à chaque fois et jusqu'à usager finaux 
	int volume_début, volume fin ( volume début volume d'un des noeuds dans la boucle )
	commencer la somme des fuites après avoir calculer la fuites de sources à usine de traitement 
	calculer fuites noeud = volume_fin; 
	à chaque fois : volume - volume_fin = +volume_pertes; ( pour le noeud de l'usine au début ? )
	à chaque fois : volume_début - volume_fin = volume_pertes; ( pour le reste ) 
	fonction count tout les enfants du noeud = nombre_enfants;
	repartir volume/nombre_enfants;
	attention a faire a chaque le calcul de tout les enfants, puis ensuite leurs enfants ainsin de suite et pas son enfant, ensuite l'enfant de l'enfant ...)
	et donc comment parcourir l'arbre comme ça ( en largeur ? )
	si pas enfant calculer les fuites du noeud ou enfants actuelle
	return volume_pertes; ( en millions de m^3 = peut être à convertir )
	appeler la fonction données fichiers 
	affiche le résultat

}

void tranforme_données_fichiers(){

	mettre à chaque fois que un volume de perte totale d'une usine est calculé : 
	si fichier existe, rajouter une nouvelle ligne
	sinon créer un fichier et rajouter la ligne
	fichier des historiques des volumes en .dat
}


// fonctions libère arbre 
- librer liste, arbre, avl 





















                                                       // ce qu'il faut mettre dans le programme principal //


main : 
- ajouter enfant
- si volume de pertes d'eau demandé par shell : 
- la fonction doit prendre en paramètre l'identifiant de l'usine 
- si identifiant pas trouver - retourner -1 sinon retourne adresse du noeud 
- continuer seulement si fonction recherche_identifiant retourne pas -1
- calcul_pertes_eau(adresse du noeud)
- mettre les données dans un fichier


notes : 
- 
-
-
-
-
-
-








i
