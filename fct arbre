        // fonctions pour construire et utiliser l'arbre //


// structures 

typedef struct{
	char id; // identifiants du distributeurs d'eau  
	Liste* enfants; // les tronçons de ce noeud 
}Arbre;

typedef struct Arbre* pArbre; 

typedef struct Liste{
	Arbre* enfant; // en aval
	float fuites; // pourcentage de fuites 
	struct Liste* suivant; //
}Liste; 

typedef struct Liste* pListe; 


// fonction qui crée arbre 

pArbre creerArbre(char e){
	pArbre noeud=malloc(sizeof(Arbre));
	if(noeud==NULL){
		exit(EXIT_FAILURE);
	}
	noeud->id=e;
	noeud->enfant=NULL;
	return noeud;
}

// fonction qui crée une liste d'enfant
pListe creerenfant(pArbre e, float fuite){
	pArbre e= mallocsizeof(Arbre);
	if(e==NULL){
		printf("Erreur allocation mémoire arbre");
		exit(EXIT_FAILURE);
	}
	e->fuite=fuites;
	


// fonction qui ajoute les enfants ( aide AVL supllémentaire pour retrouver et retourner adresse du noeud )




// fonction qui calcul la perte ( compte le nombre d'enfants + répartition volumes + addition pertes ) 



// fonction qui libère la mémoire 



// fonctions vu en cours pour arbre //

typedef struct Chainon{
  int valeur; 
  struct Chainon* next;
}Chainon; 

typedef struct{
  int valeur; 
  Arbre* fg, fd;
} Arbre; 

// création de l'arbre
pArbre creerArbre(int e){
	pArbre noeud=malloc(sizeof(Arbre));
	if(noeud==NULL){
		exit(EXIT_FAILURE);
	}
	noeud->valeur=e;
	noeud->fd=NULL;
	noeud->fg=NULL;
	return noeud;
}

// arbre vide ? 
int estVide(pArbre* a){
    return (a==NULL);
  }

// est une feuille ? 
int estFeuille(pArbre* a){
  if(a==NULL){
    exit(EXIT_FAILURE);
  }
  if(a->fd==NULL && a->fg==NULL){
    return 1;
  }
  else{
    return 0; 
  }
}

// vérifie si filsgauche/filsdroit existe 

int existeFilsDroit(pArbre* a){
  if( a==NULL ){
    exit(EXIT_FAILURE);
  }
  else if (a->fd==NULL){
    return 0; 
  }
  else{
  return 1; 
  }
}

int existeFilsGauche(pArbre* a){
  if( a==NULL ){
    exit(EXIT_FAILURE);
  }
  else if (a->fg==NULL){
    return 0; 
  }
  else{
  return 1; 
  }
}

// retourne adresse du filsdroit/fisgauche

int filsDroit( pArbre* a ){
  if( a==NULL ){
    exit(EXIT_FAILURE);
  }
  else if(existeFilsDroit(a)){
    return a->fd; 
  }
  else{
    return NULL;
  }

}
int filsGauche( pArbre* a ){
  if( a==NULL ){
    exit(EXIT_FAILURE);
  }
  else if(existeFilsGauche(a)){
    return a->fg; 
  }
  else{
    return NULL;
  }

}

// modifier élément

void modifier element( Parbre* a, int element){
  if (a == NULL){
    exit(EXIT_FAILURE);
  }
  else{
  a->value=element; 
  }
}


// ajouter fis gauche/fils droit

int ajouterFilsDroit( pArbre* a, int e){
  if(a==NULL){
    return 0; 
  }
  else if(!existeFilsDroit(a)){
    a->fd=creerArbre(e);
    return 1;
  }
  else{
    return 0; 
  }
}

int ajouterFilsGauche( pArbre* a, int e){
  if(a==NULL){
    return 0; 
  }
  else if(!existeFilsGauche(a)){
    a->fg=creerArbre(e);
    return 1;
  }
  else{
    return 0; 
  }
}


// supprimer un noeud 

void supprimerFilsDroit(pArbre* a){
  if(a==NULL){
    exit(EXIT_FAILURE);
  }
  else if(existeFilsDroit(a)){
    if(existeFilsGauche(a->fd)){
      supprimerFilsGauche(a->fd);
    }
    if(existeFilsDroit(a->fd)){
      supprimerFilsDroit(a->fd);
    }
    free(a->fd); 
  }
}

void supprimerFilsGauche(pArbre* a){
  if(a==NULL){
    exit(EXIT_FAILURE);
  }
  else if(existeFilsGauche(a)){
    if(existeFilsGauche(a->fg)){
      supprimerFilsGauche(a->fg);
    }
    if(existeFilsDroit(a->fg)){
      supprimerFilsDroit(a->fg);
    }
    free(a->fg); 
  }
}

// parcours Infixe

void parcoursInfixe(pArbre* a){
  if(a !=NULL){
    parcoursInfixe(a->fg);
    traiter(a->valeur);
    parcoursInfixe(a->fd);
  }
}

// parcours Prefixe

void traiter(pArbre* a){
	if(estVide(a)){	
		printf("vide\n");
	}
	else{
	printf("%d\n", a->valeur);
	}
}

void parcoursPrefixe(pArbre* a){
	if ( a!=NULL){
		traiter (a);
		parcoursPrefixe(a->fg);
		parcoursPrefixe(a->fd);
	}
}

// parcours Largeur 

void parcoursLargeur(pArbre* a){
	pArbre* noeud; 
	File* f; 
	if(!estVide(a)){
		creerFile(f); 
		enfiler(f, a);
		while(fileVide(f)){
			noeud=defiler(f);
			traiter(noeud);
			if(existeFilsGauche(noeud)){
				enfiler(f, noeud->fg);
			}
			if(existeFilsDroit(noeud)){
				enfiler(f, noeud->fd);
			}
		}
	}
}


