                                                                      // toutes les fonctions pour afficher la perte d'eau d'une usine //


                                                                                     // structures //

typedef struct{
	char* id; // identifiants du distributeurs d'eau
	int volume_initial;
	Liste* enfants;
}Noeud;

typedef struct Noeud* pNoeud; 

typedef struct {
	Noeud* enfant; // en aval
	float fuites_pourcentage; // pourcentage de fuites 
	struct Liste* suivant; //
}Liste; 

typedef struct Liste* pListe; 


                                                   // fonction qui crée arbre classique //

pNoeud creerNoeud(const char* identifiant){
	pNoeud noeud=malloc(sizeof(Noeud));
	if(noeud==NULL){
		return NULL;
	}
	noeud->id=malloc(strlen(identifiant)+1); // faire de la mémoire pour la chaîne de carcatère de l'identifiant
	if(noeud->id==NULL){
		free(noeud); // libérer mémoire allouée du noeud 
		return NULL;
	}
	strcpy(noeud->id, identifiant);
	noeud->volume_initial=0;
	noeud->enfants=NULL; (initialiser la liste d'enfant à NULL)
	return noeud;
}


// fonction qui crée une liste d'enfant

pListe creerenfant(pNoeud aval, float fuite){
	pListe a= malloc(sizeof(Liste));
	if(a==NULL){
		return NULL;
	}
	a->enfant=aval;
	a->fuites_pourcentages=fuite;
	a->suivant=NULL;
	return a;
}























// fonction qui ajoute les enfants ( aide AVL supllémentaire pour retrouver et retourner adresse du noeud ) = regarder partie avl et lecture du fichier déjà fait 

- structrues avl 

typedef struct avl{
	char* id;
    pNoeud Noeud;
    int eq;                   
    struct avl *fg;
    struct avl *fd;
}AVL_sup;

typedef AVL_sup *pAVL_sup;

- recherche AVL(avl, id_usines){
	- retourne adresse du neoud où se trouve le noeud
	- retourne 0 si pas trouvé 
}

- obtenir l'adresse du noeud ( cherche le noeud, ( le cré si y a aps, enrengistre dans l'avl et ) et retroune adresse )
	pour ajouter dans l'avl   
	- verifier si noeud parent existe avec avl rechercher avl qui donne l'adresse du noeud
( si non : valeur 0 : créer ), ajouter dans avl
	- verifier si noeud enfant existe
( si non créer ) mais de base y pas encore nan + ajouter dans l'avl
 lire parent, enfant, fuites
	- regarder en fonctions des lignes car pas les même en fonctions des distributions d'eau

présent dans le fichier : 

source/usine : 
- identifiant source 
- identifiant usine
- quantité annuelle capté 
- pourcentage de fuites

usine : 
- identifiant usine 
- capacité maximale de traitement

usine/stockage : 
- identifiant usine 
- identifiant stockage
- pourcentage de fuites 

stockage/jonction : 
- identifiant espace de stockage
- identifiant jonction 
- identifiant usine qui a traité l'eau 
- pourcentage de fuites 

jonction/raccordement :
- identifiant jonction 
- identifiant raccordement 
- identifiant usine qui a traité l'eau 
- pourcentage de fuites 

raccordement/usager : 
- identifiant raccordement
- identifiant usager 
- pourcentage de fuites 
- identifiant de l'usine 

pArbre ajouterenfants(Parbre, ){	                                                                                                                                                                                                                                                                    
	-  parcourir une ligne du ficheir csv 
	- creer un enfant
	- compléter l'enfant 
	- recommencer pour la ligne suivante ... 

}
- parcourir une ligne du fichier à chaque fois 
verifie si ligne utile pour rendement 
trouver l'adresse du noeud 
trouver l'enfant 
on ajoute dans la liste des enfants : enfant et pourcentage de fuites 


- construire l'arbre 
lire le fichier ligne par ligne 
elle fait traiter la ligne a chaque fois 



SCHEMA GLOBALE DU CODE : 

fonction construire arbre  : lit ligne par ligne le fichier 
fonction traiter ligne : prend identifiant amont et avl et fait obtenirnoeud(amont), obtenir(aval), ajouterenfant(amont->avl)
fonction obtenirnoeud(id amont et pareil pour id aval) - rechecrhe avl si trouvé : retroune adresse noeud 
											si pas trouvé créer neoud, insere dans avl, retourner neoud 
fonction ajouter enfant - créer enfant et ajouter dans parent->enfant 



















vérification_ identifiant(){
si identifiant pas trouver - retourner -1
si identifiant pas d'une usine ? ( on met retourner 0), ( ou on fait quand même depuis usine donc retourne adresse usine, ou on commence au noeud de l'identifiant donné donc retourne adresse du noeud) ( ou on met que les usines dans l'avl ? donc on retourne -1 vu que pas trouvé )
}

























          // fonction qui calcul la perte ( compte le nombre d'enfants + répartition volumes + addition pertes + créer le fichier et ajoute ligne dedans ) //



int compter_enfants(){

count ++
}

float calcul_pertes(adresse du noeud){
	int volume = noeud->volume_initial;
	parcourir le noeud : si enfant, continuer à chaque fois et jusqu'à usager finaux 
	int volume_début, volume fin ( volume début volume d'un des noeuds dans la boucle )
	commencer la somme des fuites après avoir calculer la fuites de sources à usine de traitement 
	calculer fuites noeud = volume_fin; 
	à chaque fois : volume - volume_fin = +volume_pertes; ( pour le noeud de l'usine au début ? )
	à chaque fois : volume_début - volume_fin = volume_pertes; ( pour le reste ) 
	fonction count tout les enfants du noeud = nombre_enfants;
	repartir volume/nombre_enfants;
	attention a faire a chaque le calcul de tout les enfants, puis ensuite leurs enfants ainsin de suite et pas son enfant, ensuite l'enfant de l'enfant ...)
	et donc comment parcourir l'arbre comme ça ( en largeur ? )
	si pas enfant calculer les fuites du noeud ou enfants actuelle
	return volume_pertes; ( en millions de m^3 = peut être à convertir )
	appeler la fonction données fichiers 
	affiche le résultat

}

void tranforme_données_fichiers(){

	mettre à chaque fois que un volume de perte totale d'une usine est calculé : 
	si fichier existe, rajouter une nouvelle ligne
	sinon créer un fichier et rajouter la ligne 
}


// fonctions libère arbre 






















                                                       // ce qu'il faut mettre dans le programme principal //


main : 
- ajouter enfant
- si volume de pertes d'eau demandé par shell : 
- la fonction doit prendre en paramètre l'identifiant de l'usine 
- si identifiant pas trouver - retourner -1 sinon retourne adresse du noeud 
- continuer seulement si fonction recherche_identifiant retourne pas -1
- calcul_pertes_eau(adresse du noeud)
- mettre les données dans un fichier


notes : 
- fichier des historiques des volumes en .dat
- 
-
-
-
-
-
-









