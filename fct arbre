                                                                      // toutes les fonctions pour afficher la perte d'eau d'une usine //


                                                                                           // structures //

typedef struct{
	char* id; // identifiants du distributeurs d'eau
	int volume_initial;
	Liste* enfants;
}Noeud;

typedef struct Noeud* pNoeud; 

typedef struct {
	Noeud* enfant; // en aval
	float fuites_pourcentage; // pourcentage de fuites 
	struct Liste* suivant; //
}Liste; 

typedef struct Liste* pListe; 


typedef struct avl{
	char* id;
    pNoeud noeud;
    int eq;                   
    struct avl *fg;
    struct avl *fd;
}AVL_sup;

typedef AVL_sup *pAVL_sup;


typedef struct {
    char usine[50];
    char amont[50];
    char aval[50];
    float volume;
    float coeff;
} LigneCSV;










                                                                                        // partie 1 : fonctions qui crées arbre classique //

pNoeud creerNoeud(const char* identifiant){
	pNoeud noeud=malloc(sizeof(Noeud));
	if(noeud==NULL){
		return NULL;
	}
	noeud->id=malloc(strlen(identifiant)+1); // faire de la mémoire pour la chaîne de carcatère de l'identifiant
	if(noeud->id==NULL){
		free(noeud); // libérer mémoire allouée du noeud 
		return NULL;
	}
	strcpy(noeud->id, identifiant);
	noeud->volume_initial=0;
	noeud->enfants=NULL; (initialiser la liste d'enfant à NULL)
	return noeud;
}


// fonction qui crée un enfant de la liste 

pListe creerenfant(pNoeud aval, float fuite){
	pListe a= malloc(sizeof(Liste));
	if(a==NULL){
		return NULL;
	}
	a->enfant=aval;
	a->fuites_pourcentages=fuite;
	a->suivant=NULL;
	return a;
}



// ajouter l'enfant

void ajouterenfant(pNoeud parent, pNoeud enfant, float fuites){
	pListe a=creerenfant(enfant, fuites);
	if (a == NULL){
		return NULL;
	}
	a->suivant=parent->enfants; 
	parent->enfants=a;
}

// créer un AVL supplémentaire

pAVL_sup creerAVL_sup(const char* id){
    pAVL_sup n = malloc(sizeof(AVL_sup));
    if (n == NULL) {
        return NULL;
    }
    n->id = malloc(strlen(id) + 1);
	if (n->id==NULL){
		free(n);
		return NULL);
	}
    strcpy(n->id, id);
	n->noeud= noeud;
    n->eq = 0;
    n->fg = NULL;
    n->fd = NULL;
    return n;
}


// rechercher noeud avec avl - retourne null ou adresse neoud 
int min(int a, int b){
    if(a < b){
        return a;
    }else{
        return b;
    }    
}

int max(int a, int b){
    if(a > b){
        return a;
    }else{
        return b;
    }    
}

int min3(int a, int b, int c){
  return min(min(a,b),c);
}

int max3(int a, int b, int c){
  return max(max(a,b),c);
}


pAVL rotationDroite(pAVL a){
    pAVL pivot = a->fg;
    int eq_a = a->eq;
    int eq_p = pivot->eq;
    a->fg = pivot->fd;
    pivot->fd = a;
    a->eq = eq_a - min(eq_p, 0) + 1;
    pivot->eq = max3(eq_a + 2, eq_a + eq_p + 2, eq_p + 1);
    return pivot;
}

pAVL rotationGauche(pAVL a){
    pAVL pivot = a->fd;
    int eq_a = a->eq;
    int eq_p = pivot->eq;
    a->fd = pivot->fg;
    pivot->fg = a;
    a->eq = eq_a - max(eq_p, 0) - 1;
    pivot->eq = min3(eq_a - 2, eq_a + eq_p - 2, eq_p - 1);
    return pivot;
}

pAVL doubleRotationGauche(pAVL a){
    a->fd = rotationDroite(a->fd);
    return rotationGauche(a);
}

pAVL doubleRotationDroite(pAVL a){
    a->fg = rotationGauche(a->fg);
    return rotationDroite(a);
}


pAVL equilibrerAVL(pAVL a){
    if (a->eq >= 2){
        if (a->fd->eq >= 0){
            return rotationGauche(a);
        }else{
            return doubleRotationGauche(a);
        }
    }else if (a->eq <= -2){
        if(a->fg->eq <= 0){
            return rotationDroite(a);
        }else{
            return doubleRotationDroite(a);
        }
    }
    return a;
}

pNoeud rechercheAVL(pAVL_sup a, char* id){
    if (a == NULL){
        return NULL;
    }
    if(strcmp(id, a->id) == 0){
        return a->noeud;
    }else if(strcmp(id, a->id) < 0){
        return rechercheAVL(a->fg, id);
    }else{
        return rechercheAVL(a->fd, id);
    }
}

// insérer noeud dans avl 

pAVL_sup insertionAVL(pAVL_sup a, const char* id, pNoeud n, int* h){
    if (a == NULL) {
        *h = 1;
        return creerAVL_sup(id, n);
    }
    
    if (strcmp(id,a->id) < 0){
        a->fg = insertionAVL_sup(a->fg, id, n, h);
        *h = -*h;
    }
	else if(strcmp(u->id, a->usine.id) > 0){
        a->fd = insertionAVL_sup(a->fd, id, n, h);
    }
	else{
        *h = 0;
        return a; 
    }

    if(*h != 0){
        a->eq += *h;
        if(a->eq == 0){
            *h = 0;
        }else{
            *h = 1;
        }
    }

    return equilibrerAVL_sup(a);
}



// regarder si noeud existe sinon créer noeud et inserer dans avl - retourner adresse neoud 

pNoeud obtenirnoeud(pAVL_sup* a, const char* id){
	pAVL_sup a = rechercheAVL(pAVL_sup* a, const char* id)
	if ( a!=NULL ){
		return a->noeud; 
	}
	else{
		pNoeud n=creerNoeud(id);
		if(n=NULL){
			return NULL;
		}
		int h=0; 
		*a=insertionAVL_sup(a, id, n, h) // on met pointeur pour que ça modifie dans tout le programme 
		return n;
	}
}
		

// fonction qui traite une ligne

void traiter_une_ligne(LigneCSV* l, pAVL_sup* a){

// source -> usine 
	
	if(strcmp(l->usine, "-")==0 && strcmp(l->amont,"-")!=0 && strcmp(l->aval, "-")!=0 && ( l->volume>0 )){
		pNoeud usine=obtenirnoeud(a, l->aval);

		float volume_après_fuites = l->volume*(1-(l->coeff/100.0));
		usine->volume_initial += volume_après_fuites; // car plusieurs sources peuvent rentrer dans une usine 


// usine 

	if(strcmp(l->usine, "-")==0 && strcmp(l->amont,"-")!=0 && strcmp(l->aval, "-")==0 && ( l->volume>0 )){
		pNoeud usine=obtenirnoeud(a, l->amont){



// usine->stockage & stockage->jonction & jonction->raccordement & raccordement->usager

	if((strcmp(l->amont, "-")!=0 && ( l->aval!=0 )&& (volume==0){
		pNoeud noeud_amont=obtenirnoeud(a, l->amont)
		pNoeud noeud_aval=obtenirnoeud(a, l->aval)

		ajouterenfant(noeud_amont, noeud_aval, l->coeff)
}


int lireLigne(FILE* f, LigneCSV* l){
	return fscanf(f, "%49[^;];%49[^;];%49[^;];%f;%f\n",l->usine, l->amont, l->aval, &l->volume, &l->coeff)==5; 
}


// construire arbre 
void construire_arbre(FILE* f, pAVL_sup* a){
	LigneCSV l;
	while(lireLigne(f, &l)){
		traiter_une_ligne(&l, a);
	}
}


// les lignes du fichier

présent dans le fichier : 

source/usine : 
1er colonne :
2ème colonne : identifiant source 
3ème colonne : identifiant usine
4ème colonne : quantité annuelle capté 
5ème colonne : pourcentage de fuites

usine : 
1er colonne :  
2ème colonne : identifiant usine
3ème colonne : 
4ème colonne : capacité maximale de traitement
5ème colonne : 

usine/stockage : 
1er colonne : 
2ème colonne : identifiant usine
3ème colonne : identifiant espace de stockage
4ème colonne : 
5ème colonne : pourcentage de fuites

stockage/jonction : 
1er colonne : identifiant usine
2ème colonne : identifiant espace de stockage
3ème colonne : identifiant jonction
4ème colonne : 
5ème colonne : pourcentage de fuites

jonction/raccordement :
1er colonne : identifiant usine
2ème colonne : identifiant jonction
3ème colonne : identifiant raccordement
4ème colonne : 
5ème colonne : pourcentage de fuites

raccordement/usager : 
1er colonne : identifiant usine
2ème colonne : identifiant raccordement
3ème colonne : identifiant usager
4ème colonne : 
5ème colonne : pourcentage de fuites



SCHEMA GLOBALE DU CODE POUR CONSTRUCTION DE L'ARBRE : 
lire une ligne du fichier : 
- traiter la ligne en fonction de la ligne si c'est pour source->usine, usine, usine->stockage ... 
- retrouver l'adresse du noeud avec l'avl 
- ajouter l'enfant dans l'arbre 
ainsi de suite jusqu'à que fichier est NULL 
































                            // partie 2 : fonctions qui calculent la perte d'eau d'une seule usine ( compte le nombre d'enfants + répartition volumes + addition pertes + créer le fichier et ajoute ligne dedans ) //


int vérification_ identifiant(){
	parcourir avl et trouver l'identfiant et vérifier que identifiant de l'usine sinon comme si pas trouvé
	et retrouver l'identifiant 
	si identifiant pas trouver - retourner -1
	si identifiant pas d'une usine ?( on met retourner 0), ( ou on fait quand même depuis usine donc retourne adresse usine, ou on commence au noeud de l'identifiant donné donc retourne adresse du noeud) ( ou on met que les usines dans l'avl ? donc on retourne -1 vu que pas trouvé )
	si identifiant trouver ok continuer 
}


int compter_enfants(Noeud* noeud){
	while (noeud->enfants!=NULL){
		count ++;
		noeud->enfants=noeud->enfants->suivant; 
	}
	return count;
}


float calcul_pertes(adresse du noeud){
	va parcourir l’ensemble des tronçons situés en aval=parcours en profondeur
	jusqu’aux usagers finaux, et faire la somme des pertes rencontrées dans chaque tronçon
	int volume = noeud->volume_initial;
	parcourir le noeud : si enfant, continuer à chaque fois et jusqu'à usager finaux 
	int volume_début, volume fin ( volume début volume d'un des noeuds dans la boucle )
	commencer la somme des fuites après avoir calculer la fuites de sources à usine de traitement 
	calculer fuites noeud = volume_fin; 
	à chaque fois : volume - volume_fin = +volume_pertes; ( pour le noeud de l'usine au début ? )
	à chaque fois : volume_début - volume_fin = volume_pertes; ( pour le reste ) 
	fonction count tout les enfants du noeud = nombre_enfants;
	repartir volume/nombre_enfants;
	attention a faire a chaque le calcul de tout les enfants, puis ensuite leurs enfants ainsin de suite et pas son enfant, ensuite l'enfant de l'enfant ...)
	et donc comment parcourir l'arbre comme ça ( en largeur ? )
	si pas enfant calculer les fuites du noeud ou enfants actuelle
	return volume_pertes; ( en millions de m^3 = peut être à convertir )
	affiche le résultat

}

void tranforme_données_fichiers(){
	
	mettre à chaque fois que un volume de perte totale d'une usine est calculé : 
	dans la ligne à mettre : l’identifiant de l’usine choisie ; son volume de pertes en millions.m^3 ; + pourcentage ? ; ( bonus : identifiant amont et aval du tronçon qui perd le plus d'eau )
	si fichier existe pas :  
		créer un fichier .dat et rajouter la ligne
		fichier des historiques des volumes en .dat
	sinon : 
		aller a la ligne du fichier
		rajouter une nouvelle ligne
}


int calcul_final_pertes( identifiant_usine){

vérification_ identifiant(identifiant_usine);
	a = calcul_pertes(adresse du noeud);
	tranforme_données_fichiers(noeud, a); 
	retourn a; 
}



// fonctions libère arbre 
- libérer liste, arbre, avl 





















                                                       // ce qu'il faut mettre dans le programme principal //


int main (){
	FILE* fichier = NULL;  // ouverture du fichier c-wildwater_v0.dat en mode lecture et écriture
	fichier = fopen("c-wildwater_v0.dat", "r+");
	if (fichier == NULL){
		printf("Ouverture du fichier impossible");
		exit(1);
	}

	pAVL_sup a= NULL; 
	constuire_arbre(fichier, &a);
	
	char id_usine[50];
	printf("Entrer l'identifiant de l'usine :");
	scanf("%49s", &id_usines);




	int pertes=calculerPertes(,);
	printf("Le volume d'eau perdue par l'usine, dont l'identifiant est %49s, est %d\n", id_usines, pertes);


	libérer mémoire;
	fclose(fichier);
	return 0; 
}

	



notes : 
- 
-
-
-
-
-
-








i
