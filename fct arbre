                                                                      // toutes les fonctions pour afficher la perte d'eau d'une usine //


// structures

typedef struct{
	char* id; // identifiants du distributeurs d'eau
	int volume_initial;
	Liste* enfants;
}Noeud;

typedef struct Noeud* pArbre; 

typedef struct {
	Noeud* enfant; // en aval
	float fuites_pourcentage; // pourcentage de fuites 
	struct Liste* suivant; //
}Liste; 

typedef struct Liste* pListe; 






// fonction qui crée arbre 
- regarder le truc de noeud du graphe = usine et autres lignes = arrêtes

pArbre creerArbre(char e){
	pArbre noeud=malloc(sizeof(Arbre));
	if(noeud==NULL){
		exit(EXIT_FAILURE);
	}
	noeud->id=e;
	noeud->enfant=NULL;
	return noeud;
}

// fonction qui crée une liste d'enfant

pListe creerenfant(pArbre e, float fuite){
	pArbre e= mallocsizeof(Arbre);
	if(e==NULL){
		printf("Erreur allocation mémoire arbre");
		exit(EXIT_FAILURE);
	}
	e->fuite_pourcentage=fuites; 
}



// fonction qui ajoute les enfants ( aide AVL supllémentaire pour retrouver et retourner adresse du noeud ) = regarder partie avl et lecture du fichier déjà fait 

recherche AVL(avl, id_usines){
	- retourne adresse du neoud où se trouve le noeud
	- retourne 0 si pas trouvé 
}

présent dans le fichier : 

source/usine : 
- identifiant source 
- identifiant usine
- quantité annuelle capté 
- pourcentage de fuites

usine : 
- identifiant usine 
- capacité maximale de traitement

usine/stockage : 
- identifiant usine 
- identifiant stockage
- pourcentage de fuites 

stockage/jonction : 
- identifiant espace de stockage
- identifiant jonction 
- identifiant usine qui a traité l'eau 
- pourcentage de fuites 

jonction/raccordement :
- identifiant jonction 
- identifiant raccordement 
- identifiant usine qui a traité l'eau 
- pourcentage de fuites 

raccordement/usager : 
- identifiant raccordement
- identifiant usager 
- pourcentage de fuites 
- identifiant de l'usine 

pArbre ajouterenfants(Parbre, ){	                                                                                                                                                                                                                                                                    
	-  parcourir une ligne du ficheir csv 
	- lire parent, enfant, fuites
	- pour ajouter dans l'avl commencer à partir de l'usine, ne pas mettre la source dedans et calculer la fuites entre source/usine et mettre dans le neoud de volume_intial   
	- verifier si noeud parent existe avec avl rechercher avl qui donne l'adresse du noeud
( si non : valeur 0 : créer ), ajouter dans avl
	- verifier si noeud enfant existe
( si non créer ) mais de base y pas encore nan + ajouter dans l'avl
	- regarder en fonctions des lignes car pas les même en fonctions des distributions d'eau
	- regarder ducoup les structures aussi pour voir si ça coordonne
	- ajouter l'enfant dans la liste chainées du parents et mettre % fuites
	- recommencer pour la ligne suivante ... 

}

vérification_ identifiant(){
si identifiant pas trouver - retourner -1
si identifiant pas d'une usine ? ( on met retourner 0), ( ou on fait quand même depuis usine donc retourne adresse usine, ou on commence au noeud de l'identifiant donné donc retourne adresse du noeud) ( ou on met que les usines dans l'avl ? donc on retourne -1 vu que pas trouvé )
}
// fonction qui calcul la perte ( compte le nombre d'enfants + répartition volumes + addition pertes ) 



int compter_enfants(){

count ++
}

float calcul_pertes(adresse du noeud){
	int volume = noeud->volume_initial;
	parcourir le noeud : si enfant, continuer à chaque fois et jusqu'à usager finaux 
	int volume_début, volume fin ( volume début volume d'un des noeuds dans la boucle )
	calculer fuites noeud = volume_fin; 
	à chaque fois : volume - volume_fin = +volume_pertes; ( pour le noeud de l'usine au début ? )
	à chaque fois : volume_début - volume_fin = volume_pertes; ( pour le reste ) 
	fonction count tout les enfants du noeud = nombre_enfants;
	repartir volume/nombre_enfants;
	attention a faire a chaque le calcul de tout les enfants, puis ensuite leurs enfants ainsin de suite et pas son enfant, ensuite l'enfant de l'enfant ...)
	et donc comment parcourir l'arbre comme ça ( en largeur ? )
	si pas enfant calculer les fuites du noeud ou enfants actuelle
	return volume_pertes; ( en millions de m^3 = peut être à convertir )
	affiche le résultat

}

void tranforme_données_fichiers(){

	mettre à chaque fois que un volume de perte totale d'une usine est calculé : 
	si fichier existe, rajouter une nouvelle ligne
	sinon créer un fichier et rajouter la ligne 
}



main : 
- ajouter enfant
- si volume de pertes d'eau demandé par shell : 
- la fonction doit prendre en paramètre l'identifiant de l'usine 
- si identifiant pas trouver - retourner -1 sinon retourne adresse du noeud 
- continuer seulement si fonction recherche_identifiant retourne pas -1
- calcul_pertes_eau(adresse du noeud)
- mettre les données dans un fichier


notes : 
- fichier des historiques des volumes en .dat
- 
-
-
-
-
-
-









